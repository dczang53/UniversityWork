-(Download tar file from given link)

-"tar -xvf coreutils-with-bug.tar.gz"
 [Extract the files from the tar file.]

-"cd coreutils-with-bug"
-"./configure"
-"make"
 [We go into the coreutils directory, run "configure"  for a Makefile, and
 use "make" to compile the source code in the "src" directory.]

 [However, this will result in an error. We run "make" a second time to check
 for the error. Below is the output of the second "make".]

make  all-recursive
make[1]: Entering directory `/w/home.14/cs/ugrad/dennisz/35L/Assign4/coreutils-with-bug'
Making all in lib
make[2]: Entering directory `/w/home.14/cs/ugrad/dennisz/35L/Assign4/coreutils-with-bug/lib'
make  all-am
make[3]: Entering directory `/w/home.14/cs/ugrad/dennisz/35L/Assign4/coreutils-with-bug/lib'
if gcc -DHAVE_CONFIG_H -DLIBDIR=\"/usr/local/lib\" -I. -I. -I..  -I.. -I.   -g -O2 -MT utimecmp.o -MD -MP -MF ".deps/utimecmp.Tpo" -c -o utimecmp.o utimecmp.c; \
        then mv -f ".deps/utimecmp.Tpo" ".deps/utimecmp.Po"; else rm -f ".deps/utimecmp.Tpo"; exit 1; fi
In file included from utimecmp.c:41:
utimens.h:2: error: conflicting types for 'futimens'
/usr/include/sys/stat.h:374: note: previous declaration of 'futimens' was here
make[3]: *** [utimecmp.o] Error 1
make[3]: Leaving directory `/w/home.14/cs/ugrad/dennisz/35L/Assign4/coreutils-with-bug/lib'
make[2]: *** [all] Error 2
make[2]: Leaving directory `/w/home.14/cs/ugrad/dennisz/35L/Assign4/coreutils-with-bug/lib'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/w/home.14/cs/ugrad/dennisz/35L/Assign4/coreutils-with-bug'
make: *** [all] Error 2

 [The error here is that there are duplicates declarations of the name
 "futimen", one in "utimecmp.c" and the other in "stat.h".]

 [Applying the patch.]
-"wget http://web.cs.ucla.edu/classes/fall17/cs35L/assign/coreutils.diff"
-"patch -p0 < coreutils.diff"

 [The patch works by renaming the "futimen" function to "coreutils_futimens"
 and changing the calls to the function to then new reference.]

-"make"
 [Compile all of the source code. It runs successfully this time.]


 [Now, to reproduce the bug.]
-"cd src"
-"tmp=$(mktemp -d)"
-"cd $tmp"
-"touch -d '1918-11-11 11:00 GMT' wwi-armistice"
-"touch now"
-"sleep 1"
-"touch now1"
-"TZ=UTCO ~/35L/Assign4/coreutils-with-bug/src/ls -lt --full-time wwi-armistice now now1"
 [Here, a temporary directory is created, three files are created in this
 directory, each with different timestamps. The "ls -lt" command is to list
 the files in this temporary directory in long name format and sorted by date,
 from newest to oldest. However, as we can see, the ordering is wrong.]

 [Output]
-rw-r--r-- 1 dennisz csugrad 0 1918-11-11 11:00:00.000000000 +0000 wwi-armistice
-rw-r--r-- 1 dennisz csugrad 0 2017-10-28 05:41:26.024364003 +0000 now1
-rw-r--r-- 1 dennisz csugrad 0 2017-10-28 05:41:14.878852765 +0000 now

-"TZ=UTCO ls -lt --full-time wwi-armistice now now1"
 [Output with normal "ls" command.]

-rw-r--r-- 1 dennisz csugrad 0 2017-10-28 05:41:26.024364003 +0000 now1
-rw-r--r-- 1 dennisz csugrad 0 2017-10-28 05:41:14.878852765 +0000 now
-rw-r--r-- 1 dennisz csugrad 0 1918-11-11 11:00:00.000000000 +0000 wwi-armistice



 [Debugging]

-"gdb ~/35L/Assign4/coreutils-with-bug/src/ls"
-"info functions"


All defined functions:

File ls.c:
int main(int, char **);
void usage(int);
static size_t calculate_columns(_Bool);
static void clear_files(void);
static int compare_atime(V, V);
static int compare_ctime(V, V);
static int compare_extension(V, V);
static int compare_mtime(V, V);
static int compare_name(V, V);
static int compare_size(V, V);
static int compare_version(V, V);
static int compstr_atime(V, V);
static int compstr_ctime(V, V);
static int compstr_extension(V, V);
static int compstr_mtime(V, V);
static int compstr_name(V, V);
static int compstr_size(V, V);
static _Bool dev_ino_compare(const void *, const void *);
static void dev_ino_free(void *);
static size_t dev_ino_hash(const void *, size_t);
---Type <return> to continue, or q <return> to quit---
static void dired_dump_obstack(const char *, struct obstack *);
static void extract_dirs_from_files(const char *, _Bool);
static void file_failure(_Bool, const char *, const char *);
static void format_user(uid_t, int);
static void format_user_or_group(const char *, long unsigned int, int);
static int format_user_or_group_width(const char *, long unsigned int);
static int format_user_width(uid_t);
static void free_pending_ent(struct pending *);
static _Bool get_funky_string(char **, const char **, _Bool, size_t *);
static uintmax_t gobble_file(const char *, enum filetype, _Bool, const char *);
static void indent(size_t, size_t);
static _Bool is_colored(enum indicator_no);
static size_t length_of_file_name_and_frills(const struct fileinfo *);
static void prep_non_filename_text(void);
static void print_current_files(void);
static void print_dir(const char *, const char *, _Bool);
static void print_file_name_and_frills(const struct fileinfo *);
static void print_long_format(const struct fileinfo *);
static void print_name_with_quoting(const char *, mode_t, int, struct obstack
     *);
static void print_type_indicator(mode_t);
static void put_indicator(const struct bin_str *);
static void queue_directory(const char *, const char *, _Bool);
---Type <return> to continue, or q <return> to quit---
static size_t quote_name(FILE *, const char *, const struct quoting_options *,
    size_t *);
static void restore_default_color(void);
static int rev_cmp_atime(V, V);
static int rev_cmp_ctime(V, V);
static int rev_cmp_extension(V, V);
static int rev_cmp_mtime(V, V);
static int rev_cmp_name(V, V);
static int rev_cmp_size(V, V);
static int rev_cmp_version(V, V);
static int rev_str_atime(V, V);
static int rev_str_ctime(V, V);
static int rev_str_extension(V, V);
static int rev_str_mtime(V, V);
static int rev_str_name(V, V);
static int rev_str_size(V, V);
static void sighandler(int);
static void sort_files(void);
static void stophandler(int);
static int xstrcoll(const char *, const char *);

 [Note that the standard linux "ls" command under the "-l" option lists
 the last-modified time, and "-t" sorts by that time. The "mtime" variable
 in the ls source code refers to modified time, so the function we should
 inspect here is "compare_mtime", because clearly only the time comparison is
 wrong.]
 [NOTE: "compare_mtime" calls "cmp_mtime".]



-"break compare_mtime"
-"r -lt --full-time wwi-armistice now now1"

(gdb) r -lt --full-time wwi-armistice now now1
Starting program: /w/home.14/cs/ugrad/dennisz/35L/Assign4/coreutils-with-bug/src/ls -lt --full-time wwi-armistice now now1
[Thread debugging using libthread_db enabled]

Breakpoint 1, compare_mtime (a=0x617160, b=0x617210) at ls.c:2884
2884    static int compare_mtime (V a, V b) { return cmp_mtime (a, b, xstrcoll); }
(gdb) s
cmp_mtime (a=0x617160, b=0x617210) at ls.c:2884
2884    static int compare_mtime (V a, V b) { return cmp_mtime (a, b, xstrcoll); }
(gdb) s
timespec_cmp (a=0x617160, b=0x617210) at ../lib/timespec.h:48
48        int diff = a.tv_sec - b.tv_sec;
(gdb) s
49        return diff ? diff : a.tv_nsec - b.tv_nsec;
(gdb) s
cmp_mtime (a=0x617160, b=0x617210) at ../lib/stat-time.h:121
121       return STAT_TIMESPEC (st, st_mtim);
(gdb) print $eax
$9 = 20
(gdb) print /x $eax
$10 = 0x14
(gdb) c
Continuing.

Breakpoint 1, compare_mtime (a=0x6170b0, b=0x617210) at ls.c:2884
2884    static int compare_mtime (V a, V b) { return cmp_mtime (a, b, xstrcoll); }
(gdb) s
cmp_mtime (a=0x6170b0, b=0x617210) at ls.c:2884
2884    static int compare_mtime (V a, V b) { return cmp_mtime (a, b, xstrcoll); }
(gdb) s
timespec_cmp (a=0x6170b0, b=0x617210) at ../lib/timespec.h:48
48        int diff = a.tv_sec - b.tv_sec;
(gdb) s
49        return diff ? diff : a.tv_nsec - b.tv_nsec;
(gdb) s
cmp_mtime (a=0x6170b0, b=0x617210) at ../lib/stat-time.h:121
121       return STAT_TIMESPEC (st, st_mtim);
(gdb) print $eax
$11 = 3123002741
(gdb) print /x $eax
$12 = 0xba253d75
(gdb) c
Continuing.
-rw-r--r-- 1 dennisz csugrad 0 1918-11-11 03:00:00.000000000 -0800 wwi-armistice
-rw-r--r-- 1 dennisz csugrad 0 2017-10-28 00:45:41.492622692 -0700 now1
-rw-r--r-- 1 dennisz csugrad 0 2017-10-28 00:45:21.390699620 -0700 now

Program exited normally.


 [Here, $eax is the register in which the return value is stored. The first
 run for "compare_mtime" returns the difference in seconds between the files
 "now" and "now1". However, in the second case, the number is a very large
 negative.]

 [The error here has to do with the fact that times are stored in epoch
 format. The 1911 date for "wwi-armistice" is represented as a negative
 32-bit number, and the other two as positive 32-bit numbers. Because the
 comparision functions are implemented as the difference between the two
 numbers, subtracting two numbers of different signs can potentially lead to
 overflow errors if the difference is to large, like the case here.]



 [Editting the source code]
-"compare_mtime" really just calls another function "cmp_mtime"
-in the declaration for the function "cmp_mtime" at line 2876, the
times are essentially compared first, and if they are equal, then the names
are compared [the return number is -1, 0, or 1, depending on the comparison
results
-the time comparison is done by function "timespec_cmp", and the result is
stored in diff
-so, we edit the "timespec_cmp" function in the file "lib/timespec.h" to
remove the subtractions and compare by normal comparison instead
(see lab4.diff for the changes)


-"cd coreutils-with-bug"
-"patch -p0 < lab4modified.diff"
-"make"

 [fixed ls in temporary folder]
-"cd src"
-"tmp=$(mktemp -d)"
-"cd $tmp"
-"touch -d '1918-11-11 11:00 GMT' wwi-armistice"
-"touch now"
-"sleep 1"
-"touch now1"
-"TZ=UTCO ~/35L/Assign4/coreutils-with-bug/src/ls -lt --full-time wwi-armistice now now1"
 [Output]
-rw-r--r-- 1 dennisz csugrad 0 2017-10-28 12:33:51.032597998 +0000 now1
-rw-r--r-- 1 dennisz csugrad 0 2017-10-28 12:33:40.893131188 +0000 now
-rw-r--r-- 1 dennisz csugrad 0 1918-11-11 11:00:00.000000000 +0000 wwi-armistice


 [Already-installed ls not in tmp directory]
-"cd ~"
-"touch -d '1918-11-11 11:00 GMT' wwi-armistice"
-"touch now"
-"sleep 1"
-"touch now1"
-"TZ=UTCO ls -lt --full-time wwi-armistice now now1"
 [Output]
-rw-r--r-- 1 dennisz csugrad 0 2054-12-17 17:28:16.000000000 +0000 wwi-armistice
-rw-r--r-- 1 dennisz csugrad 0 2017-10-28 12:25:12.411231000 +0000 now1
-rw-r--r-- 1 dennisz csugrad 0 2017-10-28 12:25:04.789539000 +0000 now

 [The reason the date appears to be in the future is because the Seasnet NFS
 is implemented with 32-bit unsigned time stamps, as opposed to the 32-bit
 signed time stamps on the Linux LFS. In the first case, the 1918 date works
 because the tmp directory is in the LFS. However, performing the same task
 in my home directory is in the NFS, and thus there is no signed bit to
 represent a past date according to the Epoch format.]




















