NAME: Dennis Zang
EMAIL: dennisczang@gmail.com
DETER USERNAME: la136dc

[1 - EAVESDROPPING]
In this section, we have 3 servers: "alice", "bob", and "eve". Server "alice" has a total of 5 users logged in: 2 instances of
"jumbo", 2 instances of "jambo", and 1 instance of "jimbo" (listed with the command "w"). Server "bob" has no logins. Server
"eve" is intended to be the "man in the middle".
For network configurations, the interface  "eth1" will be used, with "alice" having ip address "10.1.1.2 "and "bob" "10.1.1.3".
So, on server "eve", we run a man-in-the-middle attack by using ettercap to poison the ARP tables of the hosts and the default
gateway to monitor the traffic that enters and leaves the hosts "alice" and "bob" (using the command "ettercap -C -i eth1" as
root). Then, we can monitor the traffic as the "man in the middle" by using tcpdump to monitor the traffic that goes on in
the same network interface (using the command "tcpdump -i eth1 -s0 -w output.pcap" as root and "chaosreader output.pcap" to
convert the output to html format).

(1)	What kind of data is being transmitted in cleartext?
	(Make sure you eavesdrop for at least 30 seconds to make sure you get a representative sample of the communication.)
		Specifically, there are two types of cleartext data being exchanged between "10.1.1.2" and "10.1.1.3": HTTP GET requests
		long with their replies (with HTML), and telnet sessions that control and exchange information for remote sessions (from
		"bob" to "alice"). The HTTP requests specifically are for "/cgi-bin/stock.cgi" (GET request to "10.1.1.3" from users on
		"10.1.1.2") and "/cgi-bin/access1.cgi" (GET requests to "10.1.1.2" from "10.1.1.3"), which are for . The telnet sessions are the users
		logged in from "bob" executing random commands (with seemingly no purpose). There are also HTTPS packets sent, but of
		course since they're encrypted, we don't have plaintext access.
	-What ports, what protocols?
		The protocols used are telnet (port 23), HTTP (port 80), and HTTPS (port 443).
	-Can you extract identify any meaningful information from the data?
		For telnet sessions, we can see what commands are being run on telnet, and most importantly the login information (username and passwords). For HTTP data, we can see what web pages are being viewed and the GET requests to get them.
	-e.g., if a telnet session is active, what is happening in the session?
	If a file is being transferred, can you identify the data in the file?
		The telnet session merely involves a login followed by commands that don't seem to have any particular purpose (ie "cd",
		"ls", "who", "find", "ps", "uptime", and "du")
(2)	Is any authentication information being sent over the wire? e.g., usernames and passwords.
		Yes, there is login information being sent over telnet sessions.
	-If so, what are they? What usernames and passwords can you discover?
		USERNAMES	|	PASSWORDS
		jumbo		|	donald78
		jimbo		|	goofy76
		jambo		|	minnie77
(3)	Is any communication encrypted? What ports?
		HTTPS sessions on port 443 is encrypted.




[2 - REPLAY ATTACK AGAINST THE STOCK TICKER]
(1)	Explain exactly how to execute the attack, including the specific RPCs you replayed.
		To execute a replay attack, we must learn what packets are sent, and then replay those packets at a specific time one
		would like to execute a particular function. So, we begin by ARP poisoning the network with server "eve" and then
		using "tcpdump" to log what packets are being sent (like in part 1).
		In our case, we would like to perform a replay attack against the stock ticker in order to make FrobozzCo's stock look
		bad and Zembor Corp's stock look good (make FZCO's stock price as low as possible and "FZCO's as high as possible). So,
		we look at the packets being sent, and search through the HTTP requests that are specifically for setting stock prices.
		Doing so, we find the HTTP GET requests with
		"/cgi-bin/stock.cgi?symbol=FZCO&new=5&hash=2e44e0cae6f555a563387dc381334929" and
		"/cgi-bin/stock.cgi?symbol=ZBOR&new=92&hash=4720987343634ea1059674f4c8337405",
		which correspond to what we want above.
		To perform the attack, we performed a URL-based replay attack by sending URL requests with the CGI fields for "symbol"
		"new", and "hash" ("http://localhost:8118/cgi-bin/stock.cgi?symbol=FZCO&new=5&hash=2e44e0cae6f555a563387dc381334929"
		and "http://localhost:8118/cgi-bin/stock.cgi?symbol=ZBOR&new=92&hash=4720987343634ea1059674f4c8337405" with port
		forwarind). When successful, we get the notification "Got symbol: 'FZCO' Adding new figure: '5' Data accepted." or
		"Got symbol: 'ZBOR' Adding new figure: '92' Data accepted.". Note that we cannot simply change the value of "figure"
		and "new" as we like without the corresponding correct hash for verification, otherwise we would end up with a message
		like "PROTOCOL ERROR! Cryptographic stamp incorrect. Stock price update (FZCO; 3) rejected.".
		The hash seems to only depend on the value of "symbol" and "new", as there are repeated HTTP requests that are exactly
		the same at different times (true for second command here) (so we can assume that nonces are not used in the hashing for validation).
(2)	Explain how you determined that this strategy would work.
		We determined this strategy would work once we saw how HTTP requests that did the updating, and attempted to use the
		exact same request with the same CGI parameters as a test.
		Note that we cannot resend a TCP packet already sent as TCP works with sequence numbers in a session-baasis, which won't
		work with an unpoisoned network unless the attacker can time the attack perfectly (the next packet not being sent yet)
		and would be pointless in an already poisoned network. (Also note that there are also no replay scripts for HTTP like
		with Telnet.)
(3)	Execute your replay attack and show the results of your attack with a screen capture, text dump, etc. showing that you
	are controlling the prices on the stock ticker. 
	(see png file)



[3 - INSERTION ATTACK]
		Here, I wrote two filters ("symbol.filter" and "price.filter") to replace particular strings in the HTML being
		passed from "10.1.1.3" to "10.1.1.2". To run these filters, use the commands
		"etterfilter [filter_name].filter -o [filter_name].ef" and "ettercap -T -q -F [filter_name].ef -M ARP".
		The HTML can be verified to be modified by running "curl http://10.1.1.3/cgi-bin/stock.cgi" on "alice". Some sample
		modified HTML are given in "output.html" and "output2.html" for "symbol.filter" and "price.filter", respectively.
		(Note that output2.html is somewhat malformed because of the filter.)
(1)	Given the power of etterfilter and the kinds of traffic on this network, you can actually make significant changes to a
	machine or machines that you're not even logged in to. How?
		The main intention of insertion attacks is to modify what is being passed between two hosts. Some ways one can make
		significant changes to remote machines are tricking a user by supplying false information (like in this case) and get
		them to act accordingly, act as one user entirely by essentially acting on their behalf, and ruining the communication
		between two hosts (ie changing the contents of a HTTP request without changing the hash, essentially performing a
		DoS attack).
(2)	Of the cleartext protocols in use, can you perform any other dirty tricks using insertion attacks?
	The more nasty and clever they are, the better.
		One simple way to use insertion attacks to harm a user would be to drop the HTML pages or modify links on those pages
		to lead to sites loaded with malware (like harmful Javascript to target data stored in browsers). Another way would be
		to perform a DoS attack on an actual server host (ie drop all packets that have "tcp.dest == 80").



[4 - MITM VS. ENCRYPTION]
(1)	What configuration elements did you have to change?
		The configuration changes I made to the file "/etc/ettercap/etter.conf" are modifying "ec_uid" and "ec_gid" to equal
		0 (as root) (originally 65534) and uncommenting the lines
		'redir_command_on = "iptables -t nat -A PREROUTING -i %iface -p tcp --dport %port -j REDIRECT --to-port %rport"'
		'redir_command_off = "iptables -t nat -D PREROUTING -i %iface -p tcp --dport %port -j REDIRECT --to-port %rport"'
		to redirect SSL connections to the "man-in-the-middle", so the "man-in-the-middle" can use insert false SSL certificates
		generated from OpenSSL.
(2)	Copy and paste some of this data into a text file and include it in your submission materials.
		See "HTTPS.txt" in the folder "Part4".
(3)	Why doesn't it work to use tcpdump to capture this "decrypted" data?
		It is because it is the application ettercap that decrypts the SSL internally. tcpdump will only monitor what is actually being
		sent and received regardless of the encryption (and no actual decryption is being done.
(4)	For this exploit to work, it is necessary for users to blindly "click OK" without investigating the certificate issues.
	Why is this necessary?
		This condition is necessary because the SSL certificate generated by OpenSSL is to be blindly trusted to connect to the "man-in-the-middle".
		If one were to inspect whether the validity of the  SSL certificate of the actual host to connect to (ie checking the issuer of the certificate),
		one can somewhat validate the authenticity of the SSL certificate.
(5)	What is the encrypted data they're hiding? 
		The encrypted date being hidden seems to be lines from some play. Looking it up, it seems to be the script of the movie "The Matrix" (1999).
		(url: "https://sfy.ru/?script=matrix_ds")




[EXTRA CREDIT]
(1)	What observable software behavior might lead you to believe this?
		There are repeated hashes for the same requests (see part 1).
(2)	Can you reverse engineer the token? How is the token created?
		In the file "/share/education/MITM_UCLA/scripts/stock.cgi", we see the lines use to produce an MD5 hash using only "symbol" and "new".
        my $hash;
        my $tmp;
        my $sym = param('symbol');
        chomp($sym);
        my $new = param('new');
        int(chomp($new));
        my $hash;
        if (param('hash')) {
                $hash = param('hash');
                chomp($hash);
        } else {
                $hash = ""; # none supplied
        }
        my $computed = md5_hex($sym . $new);
        if ($computed ne $hash) {
                print h1("PROTOCOL ERROR!");
                print h2("Cryptographic stamp incorrect.\n");
                print h3("Stock price update ($sym; $new) rejected.");
                print h2("<a href='/cgi-bin/stock.cgi'>Reload</a>");
                print end_html();
                exit 0;
        }
		If we wanted to, we can reverse engineer the hash using the same function using any value of "symbol" and "new" we would like.
(3)	If you can reverse engineer it, can you write a script in your favorite language to post data of your choice?
	Hint: all the necessary pieces are available on the servers for both Perl and bash.
		Yes; the MD5 encryption should be the same regardless of programming language (as MD5 is a protocol).
(4)	What would be a better token? How would you implement it on both the client and server side? 
		A better token would be to include some piece of information that only the user should know. Any form of nonce
		would work in this case. Not that including time in the hash is not a strong option, as an attacker could intuitively guess this,
		and there would be no way to authenticate between authorized and unauthorized users.




